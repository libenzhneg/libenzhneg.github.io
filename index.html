<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="Benzheng Li">


    
    


<meta name="keywords" content="web前端技术分享">
<meta property="og:type" content="website">
<meta property="og:title" content="李本正技术博客">
<meta property="og:url" content="https://libenzhneg.github.io/index.html">
<meta property="og:site_name" content="李本正技术博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李本正技术博客">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="李本正技术博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>李本正技术博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: 
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Benzheng Li</a></h1>
        </hgroup>

        
        <p class="header-subtitle">技术分享的启程</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/index/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">分类标签</a></li>
                        
                            <li><a href="/archives/">随笔</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GRASP/">GRASP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC/">MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/">MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/angular/">angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/功能/">功能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小程序/">小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术分享/">技术分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术分享的启程/">技术分享的启程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组件化/">组件化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/配置/">配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面对对象/">面对对象</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Benzheng Li</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Benzheng Li</a></h1>
            </hgroup>
            
            <p class="header-subtitle">技术分享的启程</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/index/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">分类标签</a></li>
                
                    <li><a href="/archives/">随笔</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我">
</nav>
      <div class="body-wrap">
  
    <article id="post-react-多选，全选，反选" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/23/react-多选，全选，反选/" class="article-date">
      <time datetime="2019-05-23T02:28:34.833Z" itemprop="datePublished">2019-05-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <hr>
<p>title: react 多选，全选，反选<br>date: 2019-05-23 10:28:34<br>tags: [react, 技术分享, 功能]<br>categories: [前端框架, React]</p>
<h3 id="这是-antd-mobile-框架的样式-也可以是正常的多选框"><a href="#这是-antd-mobile-框架的样式-也可以是正常的多选框" class="headerlink" title="这是 antd-mobile 框架的样式(也可以是正常的多选框)"></a>这是 antd-mobile 框架的样式(也可以是正常的多选框)</h3><pre><code>render() {
    const { bookData, isCheckAll } = this.state
    return (
        &lt;Checkbox key=&quot;-1&quot; checked={isCheckAll} onChange={this.checkAll.bind(this)} /&gt;
        {bookData.map((item, index) =&gt; {
            return (
                &lt;List key={item.novel.id} content={item.novel}&gt;
                    &lt;strong className={isDelBtnShow ? &apos;&apos; : &apos;none&apos;}&gt;
                        &lt;Checkbox key={item.novel.id} checked={item.checked} onClick={e =&gt; this.delBtn(item.novel.id, e.target.checked, index)} /&gt;
                    &lt;/strong&gt;
                    &lt;p&gt;来源：{item.platform.title}&lt;/p&gt;
                &lt;/List&gt;
            )
        })}
    )
}
</code></pre><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><pre><code>constructor(props) {
    super(props)
    this.state = {
        bookData: [],
        checkData: [],
        isCheckAll: false
    }
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-react-的验证码倒计时" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/09/react-的验证码倒计时/" class="article-date">
      <time datetime="2019-05-09T01:56:03.000Z" itemprop="datePublished">2019-05-09</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/09/react-的验证码倒计时/">react 的验证码倒计时</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="react-的验证码倒计时"><a href="#react-的验证码倒计时" class="headerlink" title="react 的验证码倒计时"></a>react 的验证码倒计时</h3><pre><code>constructor(props) {
    super(props);
    this.state = {
        code: &apos;&apos;,
        title: &apos;注册/登录&apos;,
        count: 60,
        isCode: false,
        codeTitle: &apos;获取验证码&apos;,
    };
}
</code></pre><p>   handlechangeCode() {<br>        const that = this;<br>        const timer = setInterval(() =&gt; {<br>            if (that.state.count &gt; 0 ) {<br>                const title = that.state.count – + ‘秒后重新发送’;<br>                this.setState(() =&gt; ({ codeTitle: title, isCode: true }));<br>            } else {<br>                clearInterval(timer);<br>                that.setState(() =&gt; ({ isCode: false, codeTitle: ‘获取验证码’, count: 60}));<br>            }<br>        }, 1000);<br>    }</p>
<pre><code>&lt;label&gt;
    &lt;span&gt;验证码:&lt;/span&gt;
    &lt;input className=&quot;code&quot; 
        type=&quot;text&quot; 
        placeholder=&quot;输入验证码&quot;  
        defaultValue={this.state.code} /&gt;
    &lt;button className=&quot;code-btn&quot; 
        disabled={this.state.isCode} 
        onClick={this.handlechangeCode.bind(this)}&gt;{this.state.codeTitle}
    &lt;/button&gt;
&lt;/label&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端框架/">前端框架</a><a class="article-category-link" href="/categories/前端框架/React/">React</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/功能/">功能</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-现代前端框架和-jQuery-库的比较" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/07/现代前端框架和-jQuery-库的比较/" class="article-date">
      <time datetime="2019-05-07T08:43:18.000Z" itemprop="datePublished">2019-05-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/07/现代前端框架和-jQuery-库的比较/">现代前端框架和 jQuery 库的比较</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="现代前端框架和传统-jQuery-库的⽐比较"><a href="#现代前端框架和传统-jQuery-库的⽐比较" class="headerlink" title="现代前端框架和传统 jQuery 库的⽐比较"></a>现代前端框架和传统 jQuery 库的⽐比较</h3><h3 id="现代前端框架代表（angular-vue-react都是基于MVVM思想设计的框架）"><a href="#现代前端框架代表（angular-vue-react都是基于MVVM思想设计的框架）" class="headerlink" title="现代前端框架代表（angular, vue, react都是基于MVVM思想设计的框架）"></a>现代前端框架代表（angular, vue, react都是基于MVVM思想设计的框架）</h3><pre><code>数据操作视图

    通过对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过对象这个vm实现相互的绑定。这就是传说中的MVVM

单页面应用
</code></pre><h3 id="jQuery-库-依然最流行的web前端js库"><a href="#jQuery-库-依然最流行的web前端js库" class="headerlink" title="jQuery 库(依然最流行的web前端js库)"></a>jQuery 库(依然最流行的web前端js库)</h3><pre><code>Dom 操作

    jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的js的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的

多页应用
</code></pre><h3 id="angular"><a href="#angular" class="headerlink" title="angular"></a>angular</h3><pre><code>angular不太了解...(不做分析)

1.  模板功能强大丰富，自带了极其丰富的angular指令。

2. 自定义指令，自定义指令后可以在项目中多次使用。
</code></pre><h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><pre><code>1. vue的思想是响应式的，

2. 也就是基于是数据可变的，

3. 通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom

4. vue是把html，css，js组合到一起，用各自的处理方式

5. 简单的语法及项目搭建 

6. 更快的渲染速度和更小的体积
</code></pre><h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><pre><code>1. react整体是函数式的思想

2. 把组件设计成纯组件，状态和逻辑通过参数传入，

3. 单向数据流，react在setState之后会重新走渲染的流程

4. react的思路通过js来生成dom，所以设计了jsx，

5. Virtual Dom这种新颖的思路
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端框架/">前端框架</a><a class="article-category-link" href="/categories/前端框架/理论知识/">理论知识</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/angular/">angular</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术分享/">技术分享</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-组件化的优势和意义" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/07/组件化的优势和意义/" class="article-date">
      <time datetime="2019-05-07T07:16:00.000Z" itemprop="datePublished">2019-05-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/07/组件化的优势和意义/">组件化的优势和意义</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h3><pre><code>组件（Component）是对数据和方法的简单封装
</code></pre><h3 id="组件分类（我们也可以根据他的用途划分的更加详细）"><a href="#组件分类（我们也可以根据他的用途划分的更加详细）" class="headerlink" title="组件分类（我们也可以根据他的用途划分的更加详细）"></a>组件分类（我们也可以根据他的用途划分的更加详细）</h3><pre><code>复合组件（Composite Controls）

扩展组件（Extended Controls）

自定义组件（Custom Controls）
</code></pre><h4 id="现在的一些框架的使用基本上都是以组件化有划分的组件的分类"><a href="#现在的一些框架的使用基本上都是以组件化有划分的组件的分类" class="headerlink" title="现在的一些框架的使用基本上都是以组件化有划分的组件的分类"></a>现在的一些框架的使用基本上都是以组件化有划分的组件的分类</h4><pre><code>1. 普通组件（逻辑和渲染都在一个组件）

2. ul组件 （少量的逻辑 + 无状态组件）

3. 容器组件（逻辑）

4. 无状态组件 （渲染不加逻辑处理）
</code></pre><h3 id="组件化开发有那些好处呢？"><a href="#组件化开发有那些好处呢？" class="headerlink" title="组件化开发有那些好处呢？"></a>组件化开发有那些好处呢？</h3><h4 id="高内聚性，"><a href="#高内聚性，" class="headerlink" title="高内聚性，"></a>高内聚性，</h4><pre><code>组建功能必须是完整的，如我要实现下拉菜单功能，那在下拉菜单这个组件中，就把下拉菜单所需要的所有功能全部实现。
</code></pre><h4 id="低耦合度"><a href="#低耦合度" class="headerlink" title="低耦合度"></a>低耦合度</h4><pre><code>代码独立不会和项目中的其他代码发生冲突。在实际工程中，我们经常会涉及到团队协作，传统按照业务线去编写代码的方式，就很容易相互冲突，所以运用组件化方式就可大大避免这种冲突的存在、
每一个组件都有子集清晰的职责，完整的功能，较低的耦合便于单元测试和重复利用。
</code></pre><h4 id="标记鲜明，容易维护"><a href="#标记鲜明，容易维护" class="headerlink" title="标记鲜明，容易维护"></a>标记鲜明，容易维护</h4><pre><code>组件化后，我们只需要对对应的组件进行维护，不会影响到其它文件。而且文件结构清楚，方便后台人员的使用。
</code></pre><h4 id="块状化结构，并且方便扩展"><a href="#块状化结构，并且方便扩展" class="headerlink" title="块状化结构，并且方便扩展"></a>块状化结构，并且方便扩展</h4><pre><code>提高开发效率、方便重复使用、简化调试步骤、提升整个项目的可维护性、 便于协同开发
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/理论知识/">理论知识</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/组件化/">组件化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面对对象/">面对对象</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-从-MVC-到-MVVM" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/07/从-MVC-到-MVVM/" class="article-date">
      <time datetime="2019-05-07T06:27:58.000Z" itemprop="datePublished">2019-05-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/07/从-MVC-到-MVVM/">从 MVC 到 MVVM 模式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="MVC-到-MVVM"><a href="#MVC-到-MVVM" class="headerlink" title="MVC 到 MVVM"></a>MVC 到 MVVM</h3><h4 id="1-MVC：Model-模型-View-视图-controller-控制器-，主要是基于分层的目的，让彼此的职责分开"><a href="#1-MVC：Model-模型-View-视图-controller-控制器-，主要是基于分层的目的，让彼此的职责分开" class="headerlink" title="1. MVC：Model(模型)+View(视图)+controller(控制器)，主要是基于分层的目的，让彼此的职责分开"></a>1. MVC：Model(模型)+View(视图)+controller(控制器)，主要是基于分层的目的，让彼此的职责分开</h4><pre><code>工作方式：
View =&gt;  Controller  =&gt; Model =&gt;  View
</code></pre><h4 id="2-MVVM：MVVM是把MVC里的Controller改成了ViewModel。Model-View-ViewModel。ViewModel-和-Mode-是双向绑定的"><a href="#2-MVVM：MVVM是把MVC里的Controller改成了ViewModel。Model-View-ViewModel。ViewModel-和-Mode-是双向绑定的" class="headerlink" title="2. MVVM：MVVM是把MVC里的Controller改成了ViewModel。Model+View+ViewModel。ViewModel 和 Mode 是双向绑定的"></a>2. MVVM：MVVM是把MVC里的Controller改成了ViewModel。Model+View+ViewModel。ViewModel 和 Mode 是双向绑定的</h4><pre><code>工作模式：
View &lt;=&gt; ViewModel &lt;=&gt; Mode
</code></pre><h4 id="3-View的变化会自动更新到ViewModel-ViewModel的变化也会自动同步到View上显示。这种自动同步是因为ViewModel中的属性实现了Observer-观察者模式设计模式中的行为型模式的一种-，当属性变更时都能触发对应的操作。"><a href="#3-View的变化会自动更新到ViewModel-ViewModel的变化也会自动同步到View上显示。这种自动同步是因为ViewModel中的属性实现了Observer-观察者模式设计模式中的行为型模式的一种-，当属性变更时都能触发对应的操作。" class="headerlink" title="3. View的变化会自动更新到ViewModel,ViewModel的变化也会自动同步到View上显示。这种自动同步是因为ViewModel中的属性实现了Observer(观察者模式设计模式中的行为型模式的一种)，当属性变更时都能触发对应的操作。"></a>3. View的变化会自动更新到ViewModel,ViewModel的变化也会自动同步到View上显示。这种自动同步是因为ViewModel中的属性实现了Observer(观察者模式设计模式中的行为型模式的一种)，当属性变更时都能触发对应的操作。</h4>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/理论知识/">理论知识</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVC/">MVC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVVM/">MVVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术分享/">技术分享</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-什么是面对对象思想" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/07/什么是面对对象思想/" class="article-date">
      <time datetime="2019-05-07T03:54:45.000Z" itemprop="datePublished">2019-05-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/07/什么是面对对象思想/">什么是面对对象思想</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="面对对象思想"><a href="#面对对象思想" class="headerlink" title="面对对象思想"></a>面对对象思想</h3><pre><code>面对对象包含：四大基本特性：七大设计原则：23种设计模式
</code></pre><h3 id="四大基本特性："><a href="#四大基本特性：" class="headerlink" title="四大基本特性："></a>四大基本特性：</h3><pre><code>抽象：提取现实世界中某事物的关键特性，为该事物构建模型的过程。对同一事物在不同的需求下，需要提取的特性可能不一样。得到的抽象模型中一般包含：属性（数据）和操作（行为）。这个抽象模型我们称之为类。对类进行实例化得到对象。

封装：封装可以使类具有独立性和隔离性；保证类的高内聚。只暴露给类外部或者子类必须的属性和操作

继承：对现有类的一种复用机制。一个类如果继承现有的类，则这个类将拥有被继承类的所有非私有特性（属性和操作）。这里指的继承包含：类的继承和接口的实现。

多态：多态是在继承的基础上实现的。多态的三个要素：继承、重写和父类引用指向子类对象。父类引用指向不同的子类对象时，调用相同的方法，呈现出不同的行为；就是类多态特性。多态可以分成编译时多态和运行时多态。
</code></pre><h3 id="七大设计原则："><a href="#七大设计原则：" class="headerlink" title="七大设计原则："></a>七大设计原则：</h3><pre><code>SOLID原则（单一职责原则、开放关闭原则、里氏替换原则、接口隔离原则和依赖倒置原则）
</code></pre><h4 id="单一责任原则（SRP）"><a href="#单一责任原则（SRP）" class="headerlink" title="单一责任原则（SRP）"></a>单一责任原则（SRP）</h4><p>  当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。</p>
<pre><code>示例：

新建一个Rectangle类，该类包含两个方法，一个用于把矩形绘制在屏幕上，一个方法用于计算矩形的面积。

Rectangle类违反了SRP原则。Rectangle类具有两个职责，如果其中一个改变，会影响到两个应用程序的变化。

一个好的设计是把两个职责分离出来放在两个不同的类中，这样任何一个变化都不会影响到其他的应用程序。
</code></pre><h4 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h4><pre><code>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。

(1)通过增加代码来扩展功能，而不是修改已经存在的代码。
(2)若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。
(3)OCP支持替换的服务，而不用修改客户模块。

示例：

public boolean sendByEmail(String addr, String title, String content) {

}public boolean sendBySMS(String addr, String content) {

}// 在其它地方调用上述方法发送信息sendByEmail(addr, title, content);
sendBySMS(addr, content);

如果现在又多了一种发送信息的方式，比如可以通过QQ发送信息，那么不仅需要增加一个方法sendByQQ()，还需要在调用它的地方进行修改，违反了OCP原则，更好的方式是

抽象出一个Send接口，里面有个send()方法，然后让SendByEmail和SendBySMS去实现它既可。这样即使多了一个通过QQ发送的请求，那么只要再添加一个SendByQQ实现类实现Send接口既可。这样就不需要修改已有的接口定义和已实现类，很好的遵循了OCP原则。
</code></pre><h4 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h4><pre><code>当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系

客户模块不应关心服务模块的是如何工作的；同样的接口模块之间，可以在不知道服务模块代码的情况下，进行替换。即接口或父类出现的地方，实现接口的类或子类可以代入。

示例：

public class Rectangle {    private double width;    private double height;     public void setWidth(double value) {         this.width = value;
     }     public double getWidth() {         return this.width;
     }     public void setHeight(double value) {         this.width = value;
     }     public double getHeight() {         return this.height;
     }     public double Area() {         return this.width*this.height;
     }
}public class Square extends Rectangle {    /* 由于父类Rectangle在设计时没有考虑将来会被Square继承，所以父类中字段width和height都被设成private，在子类Square中就只能调用父类的属性来set/get，具体省略 */}// 测试void TestRectangle(Rectangle r) {
    r.Weight=10;
    r.Height=20;
    Assert.AreEqual(10,r.Weight);
    Assert.AreEqual(200,r.Area);
}// 运行良好Rectangle r = new Rectangle ();
TestRectangle(r);// 现在两个Assert测试都失败了Square s = new Square();
TestRectangle(s);

      LSP让我们得出一个非常重要的结论：一个模型，如果孤立地看，并不具有真正意义上的有效性，模型的有效性只能通过它的客户程序来表现。例如孤立地看Rectangle和Squre，它们时自相容的、有效的；但从对基类Rectangle做了合理假设的客户程序TestRectangle(Rectangle r)看，这个模型就有问题了。在考虑一个特定设计是否恰当时，不能完全孤立地来看这个解决方案，必须要根据该设计的使用者所作出的合理假设来审视它。

      目前也有一些技术可以支持我们将合理假设明确化，例如测试驱动开发(Test-Driven Development，TDD)和基于契约设计(Design by Contract，DBC)。但是有谁知道设计的使用者会作出什么样的合理假设呢？大多数这样的假设都很难预料。如果我们预测所有的假设的话，我们设计的 系统可能也会充满不必要的复杂性。推荐的做法是：只预测那些最明显的违反LSP的情况，而推迟对所有其他假设的预测，直到出现相关的脆弱性的臭味(Bad Smell)时，才去处理它们。我觉得这句话还不够直白，Martin Fowler的《Refactoring》一书中“Refused Bequest”(拒收的遗赠)描 述的更详尽：子类继承父类的methods和data，但子类仅仅只需要父类的部分Methods或data，而不是全部methods和data；当这 种情况出现时，就意味这我们的继承体系出现了问题。例如上面的Rectangle和Square，Square本身长和宽相等，几何学中用边长来表示边， 而Rectangle长和宽之分，直观地看，Square已经Refused了Rectangle的Bequest，让Square继承 Rectangle是一个不合理的设计。

      现在再回到面向对象的基本概念上，子类继承父类表达的是一种IS-A关系，IS-A关系这种用法被认为是面向对象分析(OOA)基本技术之一。但正方形的 的确确是一个长方形啊，难道它们之间不存在IS-A关系？关于这一点，《Java与模式》一书中的解释是：我们设计继承体系时，子类应该是可替代的父类的，是可替代关系，而不仅仅是IS-A的关系；而PPP一书中的解释是：从行为方式的角度来看，Square不是Rectangle，对象的行为方式才是软件真正所关注的问题；LSP清楚地指出，OOD中IS-A关系时就行为方式而言的，客户程序是可以对行为方式进行合理假设的。其实二者表达的是同一个意思。
</code></pre><h4 id="接口分离原则（ISP）"><a href="#接口分离原则（ISP）" class="headerlink" title="接口分离原则（ISP）"></a>接口分离原则（ISP）</h4><pre><code>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。 

客户模块不应该依赖大的接口，应该裁减为小的接口给客户模块使用，以减少依赖性。如Java中一个类实现多个接口，不同的接口给不用的客户模块使用，而不是提供给客户模块一个大的接口。

示例：

public interface Animal {

    public void eat();      // 吃

    public void sleep();    // 睡

    public void crawl();     // 爬

    public void run();      // 跑}public class Snake implements Animal {    public void eat() {

    }    
    public void sleep() {

    }  
    public void crawl() {

    }    public void run(){

    }

}public class Rabit implements Animal {    public void eat() {

    }    
    public void sleep() {

    }  
    public void crawl() {

    }    public void run(){

    }

}

上面的例子，Snake并没有run的行为而Rabbit并没有crawl的行为，而这里它们却必须实现这样不必要的方法，更好的方法是crawl()和run()单独作为一个接口，这需要根据实际情况进行调整，反正不要把什么功能都放在一个大的接口里，而这些功能并不是每个继承该接口的类都所必须的。
</code></pre><h4 id="依赖注入或倒置原则（DIP）"><a href="#依赖注入或倒置原则（DIP）" class="headerlink" title="依赖注入或倒置原则（DIP）"></a>依赖注入或倒置原则（DIP）</h4><pre><code>1. 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 
2. 抽象不应该依赖于细节，细节应该依赖于抽象

这个设计原则的亮点在于任何被DI框架注入的类很容易用mock对象进行测试和维护，因为对象创建代码集中在框架中，客户端代码也不混乱。有很多方式可以实现依赖倒置，比如像AspectJ等的AOP（Aspect Oriented programming）框架使用的字节码技术，或Spring框架使用的代理等。

(1).高层模块不要依赖低层模块；
(2).高层和低层模块都要依赖于抽象；
(3).抽象不要依赖于具体实现； 
(4).具体实现要依赖于抽象；
(5).抽象和接口使模块之间的依赖分离。

先让我们从宏观上来看下，举个例子，我们经常会用到宏观的一种体系结构模式--layer模式，通过层的概念分解和架构系统，比如常见得三层架构等。那么依赖关系应该是自上而下，也就是上层模块依赖于下层模块，而下层模块不依赖于上层，

这应该还是比较容易理解的，因为越底层的模块相对就越稳定，改动也相对越少，而越上层跟需求耦合度越高，改动也会越频繁，所以自上而下的依赖关系使上层发生变更时，不会影响到下层，降低变更带来的风险，保证系统的稳定。

上面是立足在整体架构层的基础上的结果，再换个角度，从细节上再分析一下，这里我们暂时只关注UI和Service间的关系，如下面这样的依赖关系会有什么样的问题？

第一，当需要追加提供一种新的Service时，我们不得不对UI层进行改动，增加了额外的工作。

第二，这种改动可能会影响到UI，带来风险。

第三，改动后，UI层和Logic层都必须重新再做Unit testing。


那么具体怎么优化依赖关系才能让模块或层间的耦合更低呢？想想前面讲的OCP原则吧，观点是类似的。

我们可以为Service追加一个抽象层，上层UI不依赖于Service的details，UI和Service同时依赖于这个Service的抽象层。


这样改进后会有什么好处呢？

第一，Service进行扩展时，一般情况下不会影响到UI层，UI不需要改动。

第二，Service进行扩展时，UI层不需要再做Unit testing。


作者：一只名叫tom的猫
链接：https://www.imooc.com/article/51098
来源：慕课网
</code></pre><h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><pre><code>一个对象应该对其他对象保持最少的了解。

迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的IanHolland提出。

对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。
</code></pre><h4 id="组合优于继承原则（合成复用原则）"><a href="#组合优于继承原则（合成复用原则）" class="headerlink" title="组合优于继承原则（合成复用原则）"></a>组合优于继承原则（合成复用原则）</h4><pre><code>通过创建一个由其他对象组合的对象来获得新功能的重用方法
新功能的获得是通过调用组合对象的功能实现的
有时又叫聚合
例如：
一个对象拥有或者对另外一个对象负责并且两个对象有相同的生命周期。(GOF)
一个对象包含另一个对象集合
被包含对象对其他对象是不可见的并且只能从包含它的对象中访问的特殊组合形式

组合的优缺点

    优点
        被包含对象通过包含他们的类来访问
        黑盒重用，因为被包含对象的内部细节是不可见的
        很好的封装
        每个类专注于一个任务
        通过获得和被包含对象的类型相同的对象引用，可以在运行时动态定义组合的方式
    缺点
        结果系统可能会包含更多的对象
        为了使组合时可以使用不同的对象，必须小心的定义接口

继承

    通过扩展已实现的对象来获得新功能的重用方法
    基类有用通用的属性和方法
    子类提供更多的属性和方法来扩展基类

继承的优缺点

    优点
        新的实现很容易，因为大部分是继承而来的
        很容易修改和扩展已有的实现
    缺点
        打破了封装，因为基类向子类暴露了实现细节
        白盒重用，因为基类的内部细节通常对子类是可见的
        当父类的实现改变时可能要相应的对子类做出改变
        不能在运行时改变由父类继承来的实现

由此可见，组合比继承具有更大的灵活性和更稳定的结构，一般情况下应该优先考虑组合。只有当下列条件满足时才考虑使用继承：

    子类是一种特殊的类型，而不只是父类的一个角色
    子类的实例不需要变成另一个类的对象
    子类扩展，而不是覆盖或者使父类的功能失效

链接：https://zjliu.iteye.com/blog/423223
来源：zjliu
</code></pre><h3 id="23种设计模式："><a href="#23种设计模式：" class="headerlink" title="23种设计模式："></a>23种设计模式：</h3><pre><code>创建型模式：

    工厂模式
    抽象工厂模式
    单例模式
    原型模式
    创建者模式

结构型模式：

    组合模式
    装饰者模式
    外观模式
    适配器模式
    代理模式
    享元模式
    桥接模式

行为型模式：

    观察者模式
    策略模式
    状态模式
    中介模式
    模板方法
    命令模式
    备忘录模式
    访问者模式
    解释器模式
    迭代器模式
    职责链模式
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/理论知识/">理论知识</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面对对象/">面对对象</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-GRASP-九大原则简单理解" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/07/GRASP-九大原则简单理解/" class="article-date">
      <time datetime="2019-05-07T03:11:13.000Z" itemprop="datePublished">2019-05-07</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/07/GRASP-九大原则简单理解/">GRASP 九大原则简单理解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="GRASP-（通用职责分配软件设计模式）"><a href="#GRASP-（通用职责分配软件设计模式）" class="headerlink" title="GRASP （通用职责分配软件设计模式）"></a>GRASP （通用职责分配软件设计模式）</h3><h3 id="高内聚、低耦合（High-Cohesion、Low-Coupling）"><a href="#高内聚、低耦合（High-Cohesion、Low-Coupling）" class="headerlink" title="高内聚、低耦合（High Cohesion、Low Coupling）"></a>高内聚、低耦合（High Cohesion、Low Coupling）</h3><pre><code>高内聚和低耦合是软件开发中最重要的原则，其他模式也是以高内聚、低耦合原则为中心的。

高内聚和低耦合往往是伴随在一起出现的。低耦合其实就是两个类或模块之间联系的紧密程度，高内聚就是类中方法和方法之间的职责相关性。
要想避免低内聚、高耦合，解决办法就是既要降低因为一个类的变化而对另一个类产生的影响，又要保持类或模块是有重点的、可理的、 可管理的并且支持低耦合的，也就是更加精确的给一个类或者模块分配职责。

高内聚   
   一个类具有很多紧密相关的职责，而且只完成有限的功能，则这个类就具有高内聚性

低耦合
    低耦合模式的意思就是要我们尽可能地减少类之间的连接，降低因为一个类的变化而对另一个类产生的影响。
</code></pre><h3 id="信息专家-Information-Expert"><a href="#信息专家-Information-Expert" class="headerlink" title="信息专家(Information Expert)"></a>信息专家(Information Expert)</h3><pre><code>将职责分配给拥有履行一个职责所必需信息的类，即信息专家
如何实现高内聚，也就是如何给类分配职责？分配给具有完成该职责信息的那个类。
</code></pre><h3 id="创建者（Creator）"><a href="#创建者（Creator）" class="headerlink" title="创建者（Creator）"></a>创建者（Creator）</h3><pre><code>符合下面的一个或者多个条件，则可将创建类A实例的职责分配给类B：

B包含A；
B聚合A；
B拥有初始化A的数据并在创建类A的实例时将数据传递给类A；
B记录A的实例；
B频繁使用A。
</code></pre><h3 id="控制器（Controller）"><a href="#控制器（Controller）" class="headerlink" title="控制器（Controller）"></a>控制器（Controller）</h3><pre><code>应该由哪个类来处理系统操作呢？原则就是把系统事件的处理职责分配给控制器类，这个控制器类就相当于MVC中的C。
一个控制器应当把要完成的功能委托给其他对象，它只负责协调和控制，本身不完成太多的功能。它可以将用户界面所提交的请求转发给其他类来处理，控制器可以重用，且不能包含太多业务逻辑，
</code></pre><h3 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h3><pre><code>根据类型的不同而发生变化的行为的定义职责
</code></pre><h3 id="纯虚构模式（Pure-Fabrication）"><a href="#纯虚构模式（Pure-Fabrication）" class="headerlink" title="纯虚构模式（Pure Fabrication）"></a>纯虚构模式（Pure Fabrication）</h3><pre><code>将一组高内聚的职责分配给一个虚构的或处理方便的“行为”类，它并不是问题域中的概念，而是虚构的事务，以达到支持高内聚、低耦合和重用的目的。

纯虚构模式用于解决高内聚和低耦合之间的矛盾，它要求将一部分类的职责转移到纯虚构类中，在理想情况下，分配给这种虚构类的职责是为了达到高内聚和低耦合的目的。在实际操作过程中，纯虚构有很多种实现方式，例如将数据库操作的方法从数据库实体类中剥离出来，形成专门的数据访问类，通过对类的分解来实现类的重用，新增加的数据访问类对应于数据持久化存储，它不是问题域中的概念，而是软件开发者为了处理方便而产生的虚构概念。纯虚构可以消除由于信息专家模式带来的低内聚和高耦合的坏设计，得到一个具有更好重用性的设计。在系统中引入抽象类或接口来提高系统的扩展性也可以认为是纯虚构模式的一种应用。纯虚构模式通常基于相关功能的划分，是一种以功能为中心的对象或行为对象。在很多设计模式中都体现了纯虚构模式，例如适配器模式、策略模式等等。
</code></pre><h3 id="中介（Indirection）"><a href="#中介（Indirection）" class="headerlink" title="中介（Indirection）"></a>中介（Indirection）</h3><pre><code>可以独立的改变其他系列对象的交互（其他对象不需要相互了解）
</code></pre><h3 id="防止变异（Protected-Variation）"><a href="#防止变异（Protected-Variation）" class="headerlink" title="防止变异（Protected Variation）"></a>防止变异（Protected Variation）</h3><pre><code>找出预计有变化或不稳定的元素，为其创建稳定的“接口”而分配职责。
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/理论知识/">理论知识</a><a class="article-category-link" href="/categories/理论知识/设计模式/">设计模式</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GRASP/">GRASP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术分享/">技术分享</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-vue-实用功能" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/06/vue-实用功能/" class="article-date">
      <time datetime="2019-05-06T08:58:23.000Z" itemprop="datePublished">2019-05-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/06/vue-实用功能/">vue 上拉加载</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="vue-上拉加载几行代码搞定（pc-移动端）"><a href="#vue-上拉加载几行代码搞定（pc-移动端）" class="headerlink" title="vue 上拉加载几行代码搞定（pc + 移动端）"></a>vue 上拉加载几行代码搞定（pc + 移动端）</h3><pre><code>created () {
    window.addEventListener(&apos;scroll&apos;, this.onScroll)
},

    methods: {
        onScroll () {
        let innerHeight = document.querySelector(&apos;#app&apos;).clientHeight
        let outerHeight = document.documentElement.clientHeight
        let scrollTop = document.body.scrollTop ? document.body.scrollTop : document.documentElement.scrollTop
        // 页面高度 = 屏幕高度 + 滑动高度
        if (innerHeight === (outerHeight + scrollTop)) {
            console.log(&quot; 已到底部&quot;)
        }
        }
    }
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端框架/">前端框架</a><a class="article-category-link" href="/categories/前端框架/Vue/">Vue</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/功能/">功能</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术分享/">技术分享</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-react-项目配置" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/06/react-项目配置/" class="article-date">
      <time datetime="2019-05-06T08:47:17.000Z" itemprop="datePublished">2019-05-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/06/react-项目配置/">react 项目配置</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="注意事项（报错）"><a href="#注意事项（报错）" class="headerlink" title="注意事项（报错）"></a>注意事项（报错）</h3><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org
&apos;react-scripts&apos; 不是内部或外部命令，也不是可运行的程序
或批处理文件。

    // 有时在安装完其他组件后，再次运行 npm start 命令时会报以上错误，
    ## 解决方案1：
    npm install react-scripts
    安装完成后再次运行 npm start 即可
    ## 解决方案2：
    删除modules 文件
    npm install
    安装完成后再次运行 npm start 即可
</code></pre><h3 id="安装的单词缩写"><a href="#安装的单词缩写" class="headerlink" title="安装的单词缩写"></a>安装的单词缩写</h3><pre><code>==&gt; i = install （安装）
&gt; -g = global (全局)

&gt; -S = --save (发布到开发环境)

&gt; -D = --save-dev (发布到生产环境)
</code></pre><h3 id="引入了三个库文件"><a href="#引入了三个库文件" class="headerlink" title="引入了三个库文件"></a>引入了三个库文件</h3><pre><code>react.min.js - React 的核心库
react-dom.min.js - 提供与 DOM 相关的功能
babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码，这样我们就能在目前不支持 ES6 浏览器上执行 React 代码。Babel 内嵌了对 JSX 的支持。通过将 Babel 和 babel-sublime 包（package）一同使用可以让源码的语法渲染上升到一个全新的水平。
</code></pre><h3 id="安装公共仓库"><a href="#安装公共仓库" class="headerlink" title="安装公共仓库"></a>安装公共仓库</h3><pre><code>###### npm i redux -S

创建 store -&gt; index.js  reducer.js  actionCreators.js  actionTypes.js

// index.js (调试工具&gt;安装 REDUX_DEVTOOLS)

import { createStore } from &apos;redux&apos;;
import reducer from &apos;./reducer&apos;;

const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__());
export default store;

// actionTypes.js  
export const CHANGE_INPUT_VALUE = &apos;change-inpue-value&apos;;

// actionCreators.js      
import { CHANGE_INPUT_VALUE } from &apos;./actionTypes&apos;;
export const getInputChangeAction = (value) =&gt; ({
    type: CHANGE_INPUT_VALUE,
    value
});

//  reducer.js
import { CHANGE_INPUT_VALUE } from &apos;./actionTypes&apos;;
const defaultState = {
    inputValue: &apos;222&apos;,
    list: [&apos;ewewee&apos;,&apos;ewewe&apos;]
};
export default (state = defaultState, action) =&gt; {
    if (action.type === CHANGE_INPUT_VALUE) {
        const NewState = JSON.parse(JSON.stringify(state));
        NewState.inputValue = action.value;
        return NewState;
    }
    return state;
}


// 组件调用

import store from &apos;./store/index&apos;
import { getInputChangeAction } from &apos;./store/actionCreators&apos;;

constructor(props) {
    super(props);
    console.log(store.getState())
    this.state = {

    }
    this.chageget = this.chageget.bind(this)
    store.subscribe(this.chageget) // 数据改变是更新
}

chageget() {
    console.log(store.getState())
}

// 获取数据

store.getState()

 // 添加数据

handleInputValue(event) {
&lt;!--const action = {--&gt;
&lt;!--  type: &apos;change_input_value&apos;,--&gt;
&lt;!--  value: event.target.value--&gt;
&lt;!--}--&gt;
const action = getInputChangeAction(event.target.value);
store.dispatch(action);
};
</code></pre><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><pre><code>数据放入缓存
localStorage.setItem(&apos;user&apos;,values.username);

缓存中取数据
localStorage.getItem(&apos;user&apos;);
</code></pre><h6 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h6><p>npm i react-redux -S</p>
<h6 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h6><p>npm i redux-thunk -S</p>
<pre><code>// index.js (调试工具&gt;安装 REDUX_DEVTOOLS)
import { createStore, applyMiddleware, compose } from &apos;redux&apos;;
import thunk from &apos;redux-thunk&apos;;
import reducer from &apos;./reducer&apos;;

const composeEnhancers =  window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose;
const enhancer = composeEnhancers(
    applyMiddleware(thunk),
)
const store = createStore(reducer,enhancer);
export default store;

// actionCreators.js
import { CHANGE_INPUT_VALUE } from &apos;./actionTypes&apos;;
import axios from &apos;axios&apos;;  
export const getInputChangeAction = (value) =&gt; ({
type: CHANGE_INPUT_VALUE,
value
});
export const getList = () =&gt; {
return (dispatch) =&gt; {
    axios.get(url ,{page: 1, limit: 10, token:token}).then((res)=&gt;{
        const data = res.data.data.list;
        const action = getInputChangeAction(data);
        dispatch(action);
    })
}
}

 // 组件调用
import store from &apos;./store/index&apos;;
import { getInputChangeAction, getList } from &apos;./store/actionCreators&apos;;

getList() {
const action = getList();
store.dispatch(action);
}


npm i redux-sage -S
</code></pre><h6 id="安装路由-react-router-dom"><a href="#安装路由-react-router-dom" class="headerlink" title="安装路由 react-router-dom"></a>安装路由 react-router-dom</h6><p>npm i react-router-dom  -S</p>
<pre><code>// index.js 入口文件
import React from &apos;react&apos;;
import ReactDOM from &apos;react-dom&apos;;
import &apos;antd/dist/antd.css&apos;;   // 框架样式
import &apos;./index.css&apos;;       // 自定义样式
import Index from &apos;./view/common/index&apos;;  // 首页的路径
import { BrowserRouter } from &apos;react-router-dom&apos;; // 路由文件
// HashRouter 和 BrowserRouter 都能实现跳转  HashRouter 前多个 #

ReactDOM.render(
    // 必须要包住路径才能实现跳转
    &lt;BrowserRouter&gt; 
        &lt;Index /&gt;
    &lt;/BrowserRouter&gt;
, document.getElementById(&apos;root&apos;));


// 新建 router -&gt;index.js
import React from &apos;react&apos;;
import {Switch, Route, Redirect} from &apos;react-router-dom&apos;;
import Index from &apos;../view/index/index&apos;;

export default class Routers extends React.Component{
    render() {
        return(
            &lt;Switch&gt;
                &lt;Route path=&quot;/&quot; exact render={()=&gt;(&lt;Redirect to=&quot;/index&quot; /&gt;)}/&gt;
                &lt;Route path=&quot;/index&quot; component={Index}/&gt;
            &lt;/Switch&gt;
        )
    }
}

方法跳转：

this.props.history.push(&apos;/download&apos;)
跳转到外链：

window.location.href = &apos;https://你的url&apos;
</code></pre><h6 id="数据获取-axios"><a href="#数据获取-axios" class="headerlink" title="数据获取 axios"></a>数据获取 axios</h6><pre><code>npm i axios  -S

在package.json中
  &quot;proxy&quot;: &quot;http://service.n.co&quot;


import React from &apos;react&apos;;
import { Table } from &apos;antd&apos;; // antd UL
import axios from &apos;axios&apos;;  

export default class User extends React.Component{
  constructor(props){
    super(props)
    this.state={
      data: []

    }
  };
    componentWillReceiveProps(){
        this.getData();
    }
    getData(){
      let that = this;
      axios.get(&apos;/backend/account/index&apos;,{page: 1, limit: 10, token:token})
      .then((res)=&gt;{
          that.setState({data:res.data.data.list})
      })
      .catch((error)=&gt;{
      });
    };

    render() {
        return(
            &lt;Table dataSource={this.state.data} rowKey=&quot;id&quot; /&gt;
        )
    }
}
</code></pre><h3 id="antd-ul-安装"><a href="#antd-ul-安装" class="headerlink" title="antd ul 安装"></a>antd ul 安装</h3><pre><code>npm i antd  -S

https://ant.design/docs/react/use-with-create-react-app-cn
</code></pre><h3 id="安装：开发环境"><a href="#安装：开发环境" class="headerlink" title="安装：开发环境"></a>安装：开发环境</h3><h5 id="修改配置环境-以适应antd-官网参考"><a href="#修改配置环境-以适应antd-官网参考" class="headerlink" title="修改配置环境,以适应antd(官网参考)"></a>修改配置环境,以适应antd(官网参考)</h5><pre><code>npm i react-app-rewired -D

npm i babel-plugin-import -D  // 按需加载 
</code></pre><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><pre><code>//站位符可以替代最外围标签

    &lt;Fragment&gt;

//构造函数

    constructor(props) {
    super(props); //调用方法
    this.state = { // 组件状态
        }
    }

// 展开运算符

    this.setState({
                list: [...this.state.list, this.state.inputVal ],
                inputVal: &apos;&apos;
            })

// immutable
// state 不予许我们做任何改变

// 转意
dangerouslySetInnerHTML={{__html: item }}

//  lable 标签

    &lt;label htmlFor=&quot;inp&quot;&gt;输入类容&lt;/label&gt;
                &lt;input id=&quot;inp&quot; className=&quot;input&quot; value={this.state.inputVal} onChange={this.changInput.bind(this)} /&gt;
                &lt;button onClick={this.btnClick.bind(this)}&gt;提交&lt;/button&gt;
</code></pre><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><pre><code>// 绑定事件
this.btnClick = this.btnClick.bind(this);

// 循环渲染封装方法

getList() {
    return this.state.list.map((item, index) =&gt; {
        return (
            &lt;List 
                key={index}
                content={item}  // 向子组件传值
                index={index}
                del={this.del}// 向子组件传方法
            /&gt;
        )
    })
}
// 子组件调用
render() {
    const { content } = this.props;
    return(
        &lt;div onClick={this.leClick}&gt;
            {content}
        &lt;/div&gt;
    )
}

leClick() {
    const { del, index } = this.props;
    del(index);
}

// es6改变状态值方法

this.setState((prevState) =&gt; ({
        list: [...prevState.list, prevState.inputVal ],
        inputVal: &apos;&apos;
    }));

    del(index) {
    this.setState((prevState) =&gt; {
        let list = [...prevState.list];
        list.splice(index, 1);
        return {list}
    });
}
</code></pre><p>// 传值类型</p>
<pre><code>npm install --save prop-types
    import PropTypes from &apos;prop-types&apos;;
    List.propTypes = {
        test: PropTypes.string.isRequired, //必须传
        test: PropTypes.arrayOf(PropTypes.string, PropTypes.number), // 或者
        content: PropTypes.string,
        del: PropTypes.func,
        index: PropTypes.number
    }
    // 默认值
    List.defaultProps = {
    test: &apos;hello&apos;
}
</code></pre><h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><pre><code>Reactdevelopertools  REDUX_DEVTOOLS
安装及使用

谷歌浏览器 =&gt; 更多工具 =&gt; 扩展程序 =&gt; 打开谷歌应用商店 =&gt; 搜索 react =&gt; 安装
=&gt; 浏览器中打开开发者工具 =&gt; react
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/前端框架/">前端框架</a><a class="article-category-link" href="/categories/前端框架/React/">React</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术分享/">技术分享</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/配置/">配置</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-小程序方法总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/05/06/小程序方法总结/" class="article-date">
      <time datetime="2019-05-06T08:32:57.000Z" itemprop="datePublished">2019-05-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/06/小程序方法总结/">小程序方法总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="小程序自定义函数"><a href="#小程序自定义函数" class="headerlink" title="小程序自定义函数"></a>小程序自定义函数</h3><pre><code>// 在需要的页面顶部引入
&lt;wxs module=&quot;common&quot; src=&quot;../../utils/common.wxs&quot;&gt;&lt;/wxs&gt;
// module  文件名  src 文件的路径

{{common.subStrCut(introduce, 60)}}

// 使用时 common 文件下的 subStrCut 方法 

### common.wxs 

/**
 * 自定义过滤函数
 */
var filters = {
  /**
   * 字符串截取
   * 
   * str 需要截取的字符串
   * len 字符需要截取的长度
   * 
   */
  subStrCut: function (str, len) {
    return str.substring(0, len);
  },
}
// 输出对象
module.exports = {
  subStrCut: filters.subStrCut
}
</code></pre><h3 id="点击事件返回的参数"><a href="#点击事件返回的参数" class="headerlink" title="点击事件返回的参数"></a>点击事件返回的参数</h3><pre><code>##  wxml
// data-id=&quot;{{ item.id }}&quot; 
// data-index=&quot;{{ index }}&quot;
// data-prefix=&quot;{{ item.prefix }}&quot;
传参 (只有这边传了参数下面event 里面才能接受到)

&lt;i-swipeout i-class=&quot;i-swipeout-demo-item&quot; wx:for=&quot;{{ list }}&quot; wx:key=&quot;{{ index }}&quot; wx:for-item=&quot;item&quot; data-id=&quot;{{ item.id }}&quot; data-index=&quot;{{ index }}&quot; data-prefix=&quot;{{ item.prefix }}&quot; bind:change=&quot;handleBtn&quot; actions=&quot;{{ actions }}&quot;&gt;
    &lt;view slot=&quot;content&quot;&gt;
      &lt;navigator wx:if=&quot;{{ item.history.hasHistory == true }}&quot; url=&apos;&apos;&gt;
        &lt;image class=&quot;book-images&quot; src=&apos;https://bookcover.yuewen.com/qdbimg/349573/1011705052&apos;&gt;&lt;/image&gt;
        &lt;i-cell title=&quot;{{ item.title }}&quot;&gt;&lt;/i-cell&gt;
      &lt;/navigator&gt;   
      &lt;navigator wx:else url=&apos;&apos;&gt;
        &lt;image class=&quot;book-images&quot; src=&apos;https://bookcover.yuewen.com/qdbimg/349573/1011705052&apos;&gt;&lt;/image&gt;
        &lt;i-cell title=&quot;{{ item.title }}&quot;&gt;&lt;/i-cell&gt;
      &lt;/navigator&gt;
      &lt;view class=&quot;trace&quot;&gt;上次读到：{{ item.history.chapter.title }}&lt;/view&gt;
      &lt;view class=&quot;trace&quot;&gt;更新时间:&lt;/view&gt;
    &lt;/view&gt;
  &lt;/i-swipeout&gt;


  &lt;!-- &lt;i-swipeout wx:for=&quot;{{ list }}&quot; wx:key=&quot;{{ index }}&quot; wx:for-item=&quot;item&quot; data-index=&quot;{{ index }}&quot; data-prefix=&quot;{{ item.prefix }}&quot; bind:change=&quot;handleBtn&quot; actions=&quot;{{ actions }}&quot;&gt;
    &lt;view slot=&quot;content&quot;&gt;
      &lt;i-cell title=&quot;{{ item.novel.title }}&quot; label=&quot;{{ item.novel.author }}&quot; value=&quot;{{ item.chapter.title }}&quot; is-link url=&quot;/pages/content/index?novelId={{item.novel.id}}&amp;code={{ item.prefix }}&amp;chapterId={{ item.chapter.id }}&amp;platformId={{ item.platform.id }}&quot;&gt;&lt;/i-cell&gt;
    &lt;/view&gt;
&lt;/i-swipeout&gt; --&gt;

  ## js
handleBtn: function (event) {
    const index = event.target.dataset.index;
    const novelId = event.target.dataset.id;
    this.likePass(novelId, index);
},
</code></pre><h3 id="代码记录"><a href="#代码记录" class="headerlink" title="代码记录"></a>代码记录</h3><pre><code>   handleBtn: function (event) {
   // const actionIndex = event.detail.index;
   const index = event.target.dataset.index;
   const novelId = event.target.dataset.id;
   // const platformId = event.target.dataset.pid;
   this.likePass(novelId, index);
   // if (novelId &gt; 0) {
   //   switch (actionIndex) {
   //     case 0:
   //       wx.navigateTo({ url: &apos;/pages/detail/index?id=&apos; + novelId + &apos;&amp;platformId=&apos; + platformId });      
   //       break;
   //     case 1:
   //       this.likePass(novelId, index);
   //       break;
   //     default:
   //   }
   // }
 },

### 想数组后添加字段

let contents = data.contents.concat(data.contents.unshift(title));
</code></pre><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><pre><code>操作     异步方法            同步方法
插入     wx.setStorage        wx.setStorageSync
读取     wx.getStorage        wx.getStorageSync
删除     wx.removeStorage   wx.removeStorageSync
清空     wx.clearStorage    wx.clearStorageSync
获取（全部缓存信息）wx.getStorageInfo     wx.getStorageInfoSync

Page({
    save: function(e){
    console.log(&apos;开始保存&apos;)
    // 异步
    wx.setStorage({
      key: &apos;key1&apos;,
      data: &apos;data1&apos;,
      success: function(res){
        console.log(&apos;异步保存成功&apos;)
      }
    })
    // 获取缓存数据
    const openId = wx.getStorageInfo(&apos;openId&apos;) 

    // 同步缓存
    wx.setStorageSync(&apos;key2&apos;, &apos;data2&apos;)
    console.log(&apos;同步保存成功&apos;)
  }
})
</code></pre><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><pre><code>redirectTo：关闭当前页，跳转到指定页；
navigateTo：保留当前页，跳转到指定页；
switchTap：只能用于跳转到tabbar页面，并关闭其他非tabbar页面。

onUnload: function () {
    wx.redirectTo({
      url: &apos;../index/index&apos;
    })
    wx.navigateTo({
      url: &apos;../index/index&apos;
    })
    wx.switchTab({
      url: &apos;../../member/member&apos;
    })
  },
</code></pre><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>&lt;img src=’<a href="https://upload-images.jianshu.io/upload_images/2210124-97d8396f573ed57e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/792" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/2210124-97d8396f573ed57e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/792</a> /&gt;</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/小程序/">小程序</a><a class="article-category-link" href="/categories/小程序/前端框架/">前端框架</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小程序/">小程序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术分享/">技术分享</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2019 Benzheng Li
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style="display:none">
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit" title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
             title: "a.article-title, .article-more-link a", 
            
             tags: ".article-tag a", 
             categories: ".article-category a, a.tag-list-link", 
             articleNav: "#article-nav a, #post-nav-button a", 
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
             menu: ".header-menu a", 
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>